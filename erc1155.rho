new 
  filesModuleCh,
  createTokenCh,
  purchaseCh,
  entryCh,
  entryUriCh,
  updateUriCh,
  hashCh,
  verifySignatureCh,
  tokens,
  tokensData,
  tokensAvailable,
  insertArbitrary(`rho:registry:insertArbitrary`),
  stdout(`rho:io:stdout`),
  secpVerify(`rho:crypto:secp256k1Verify`),
  blake2b256(`rho:crypto:blake2b256Hash`)
in {


  /*
    tokens: {
      [id: number (incremental id)]: {
        publicKey: string (public key),
        n: number (token id),
        quantity: number
      }
    }
  */
  tokens!({}) |

  /*
    tokensData: {
      [n: number (token id)]: string (unforgeable name)
    }
  */
  tokensData!({}) |

  /*
    tokensAvailable: {
      [n: number (token id)]: number (quantity)
    }
  */
  tokensAvailable!({}) |

  // add a token (1 or more)
  contract createTokenCh(payload, return) = {
    stdout!("createTokenCh") |

    for (@currentTokensAvailable <- tokensAvailable) {
      stdout!("currentTokensAvailable") |
      stdout!(currentTokensAvailable) |
      match currentTokensAvailable.size() {
        n => {
          tokensAvailable!(
            currentTokensAvailable.set(n, *payload.get("quantity"))
          ) |
          for (@currentTokensData <- tokensData) {
            stdout!("currentTokensData") |
            stdout!(currentTokensData) |
            tokensData!(
              currentTokensData.set(n, *payload.get("data"))
            )
          } |
          return!("success : token created")
        }
      }
    }
  } |

  // purchase token (1 or more)
  contract purchaseCh(payload, return) = {
    stdout!("purchaseCh") |

    for (@currentTokensAvailable <- tokensAvailable) {
      match currentTokensAvailable.get(*payload.get("n")) {
        Nil => {
          tokensAvailable!(currentTokensAvailable) |
          return!("error : token n°" ++ *payload.get("n") ++ " does not exist")
        }
        _ => {
          match currentTokensAvailable.get(*payload.get("n")) - *payload.get("quantity") >= 0 {
            false => {
              tokensAvailable!(currentTokensAvailable) |
              return!("error : no tokens n°" ++ *payload.get("n") ++ " not available")
            }
            true => {
              for (@currentTokens <- tokens) {
                match currentTokens.size() {
                  size => {
                    tokens!(
                      currentTokens.set(
                        size,
                        *payload
                      )
                    ) |
                    tokensAvailable!(
                      currentTokensAvailable.set(
                        *payload.get("n"),
                        currentTokensAvailable.get(*payload.get("n")) - *payload.get("quantity")
                      )
                    ) |
                    return!(true)
                  }
                }
              }
            }
          }
        }
      }
    }
  } |

  contract entryCh(action, return) = {
    match *action.get("type") {
      "READ_TOKENS_AVAILABLE" => {
        for (@currentTokensAvailable <<- tokensAvailable) {
          return!(currentTokensAvailable)
        }
      }
      "READ_TOKENS" => {
        for (currentTokens <<- tokens) {
          return!(*currentTokens)
        }
      }
      "READ_TOKENS_DATA" => {
        for (@currentTokensData <<- tokensData) {
          return!(currentTokensData)
        }
      }
      "READ" => {
        for (current <<- filesModuleCh) {
          return!(*current)
        }
      }
      "CREATE" => {
        match *action.get("payload") {
          { "quantity": Int, "data": _ } => {
            createTokenCh!(*action.get("payload"), *return)
          }
          _ => {
            return!("error: invalid payload, structure should be { \"quantity\": Int, \"data\": _ }")
          }
        }
      }
      "PURCHASE" => {
        match *action.get("payload") {
          { "quantity": Int, "n": Int, "publicKey": String } => {
            purchaseCh!(*action.get("payload"), *return)
          }
          _ => {
            return!("error: invalid payload, structure should be { \"quantity\": Int, \"n\": Int, \"publicKey\": String }")
          }
        }
      }
      _ => {
        return!("error: unknown action")
      }
    }
  } |

  insertArbitrary!(*entryCh, *entryUriCh) |

  for (entryUri <- entryUriCh) {

    filesModuleCh!({
      "registryUri": *entryUri,
      "publicKey": "PUBLIC_KEY",
      "nonce": "NONCE",
      "version": "0.1"
    }) |
    stdout!({
      "registryUri": *entryUri,
      "publicKey": "PUBLIC_KEY",
      "nonce": "NONCE",
      "version": "0.1"
    })
  }
}
